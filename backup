
//struct timeval {
//    time_t      tv_sec;     /* 秒 */
//    suseconds_t tv_usec;    /* マイクロ秒 */
//};
suseconds_t get_millisecond(struct timeval timevalue){
	return (timevalue.tv_sec * MILLION + timevalue.tv_usec);
}

int hasToUpdate(t_tetris *tetris){
	const suseconds_t now = get_millisecond(tetris->timevalue->now);
	const suseconds_t before_now = get_millisecond(tetris->timevalue->before_now);
	return (now - before_now > timer_millisecond);
}


aaaa4();
						//int i, j;
						//for(i = 0; i < current.width_and_height ;i++){
						//	for(j = 0; j < current.width_and_height ; j++){
						//		if(current.figure[i][j])
						//			playing_field[current.row+i][current.col+j] = current.figure[i][j];
						//	}
						//}
bbb5()
						int n, m, sum, count=0;
						for(n=0;n<FIELD_ROW;n++){
							sum = 0;
							for(m=0;m< FIELD_COL;m++) {
								sum+=playing_field[n][m];
							}
							if(sum==FIELD_COL){
								count++;
								int l, k;
								for(k = n;k >=1;k--)
									for(l=0;l<FIELD_COL;l++)
										playing_field[k][l]=playing_field[k-1][l];
								for(l=0;l<FIELD_COL;l++)
									playing_field[k][l]=0;
								timer-=decrease--;
							}
						}

  	int input_from_keyboard;
		if ((input_from_keyboard = getch()) != ERR) {
			case_getch(&tetris, input_from_keyboard);
		//	t_tetrimino temp = create_tetrimino(current);
		//	switch(input_from_keyboard){
		//		case 's':
		//			temp.row++;  //move down
		//			if(can_move_field(&temp))
		//				current.row++;
		//			else {
		//				aaaa4();
		//				int completed_lines = count_completed_lines_and_erase();
		//				tetris.score += 100 * completed_lines;
		//				ccc3(&tetris);
		//			}
		//			break;
		//		case 'd':
		//			case_d(temp);
		//			break;
		//		case 'a':
		//			case_a(temp);
		//			break;
		//		case 'w':
		//			case_w(temp,current);
		//			break;
		//	}
		//	destroy_tetrimino(&temp);
		//	refresh_game_screen(&tetris);
		}